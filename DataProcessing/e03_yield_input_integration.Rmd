# Combine yield and input datasets

## Preparation

### Read datasets

**Yield**

```{r }
#--- yield ---#
yield_polygons <- here("Data/Growers", ffy, "Intermediate/yield_polygons.rds") %>%
  readRDS() %>%
  mutate(yield_area = as.numeric(st_area(.)))

# === vis ===#
tm_shape(filter(yield_polygons, drop_as_outliers == 0)) +
  tm_fill(col = "yield_vol", style = "order")
```

**Inputs and their Rx (if exist)**

```{r }
# input_polygons$rx_polygons

input_polygons <-
  input_trial_data %>%
  rowwise() %>%
  mutate(
    input_file_name = here(
      "Data/Growers", ffy, "Intermediate",
      paste0("aa-", input_type, "-", form, ".rds")
    )
  ) %>%
  # === input ===#
  mutate(input_polygons = list(readRDS(input_file_name))) %>%
  # === rx ===#
  mutate(rx_polygons = list(
    if (Rx_data != "none") {
      st_read(here("Data/Growers", ffy, "Raw", Rx_data)) %>%
        mutate(rx_id = 1:nrow(.))
    } else {
      NULL
    }
  ))
```

### Input polygons

```{r }

input_polygons %>%
  mutate(
    tm_map = list(
      tm_shape(input_polygons) +
        tm_fill(
          col = "input_rate",
          title = paste0(input_type, "-", form)
        ) +
        tm_layout_to_add
    )
  ) %>%
  .$tm_map
```

### Rx polygons

```{r eval = F}


input_polygons %>%
  filter(Rx_data != "none") %>%
  mutate(
    tm_map = list(
      tm_shape(rx_polygons) +
        tm_polygons(
          col = form,
          title = paste0(input_type, "-", form)
        ) +
        tm_layout_to_add
    )
  ) %>%
  .$tm_map
```

**Base input rate**

```{r }
n_base <- trial_info$n_base_rate
```

## Data alignment checks

Visually check whether yield data points are aligned well with as-applied input data points.

### Yield and inputs

```{r }
tm_alignment <-
  input_polygons %>%
  mutate(
    tm_map = list(
      tm_shape(input_polygons) +
        tm_borders(lwd = 0.2) +
        tm_shape(st_centroid(yield_polygons)) +
        tm_dots(col = "blue", title = "Yield Points")
    )
  )

tm_alignment$tm_map
```

## Missing input data points due to 0 target rate

+ 1. (polygon 1): find the portions of the field where target N rate is 0

+ 2. (polygon 2) intersect existing as-applied N points with (1) to identify polygons where as-applied data-points are missing

+ 3. intersect the yield polygons with polygon 2 to flag whether application was zero, but not missing

```{r }
#* check if rx data files are available for missing points problem
num_rx_data <-
  input_polygons %>%
  filter(Rx_data != "none") %>%
  nrow()

if (num_rx_data != 0) {
  rx_no_aa_data <-
    input_polygons %>%
    filter(Rx_data != "none") %>%
    mutate(rx_polygons = list(
      rx_polygons %>%
        mutate(area = as.numeric(st_area(.))) %>%
        setnames(form, "tgt") %>%
        mutate(tgt = as.numeric(tgt))
    )) %>%
    mutate(input_centroid = list(
      st_centroid(input_polygons)
    )) %>%
    mutate(rx_input = list(
      st_join(
        rx_polygons,
        st_transform(input_centroid, st_crs(rx_polygons))
      )
    )) %>%
    mutate(rx_nums = list(
      data.table(rx_input)[, .(num_points = .N), by = rx_id]
    )) %>%
    mutate(rx_polygons = list(
      left_join(rx_polygons, rx_nums, by = "rx_id") %>%
        mutate(points_per_area = num_points / area)
    )) %>%
    mutate(rx_no_points = list(
      rx_polygons %>%
        filter(tgt == 0) %>%
        filter(points_per_area < median(rx_polygons$points_per_area) * 0.3)
    )) %>%
    # mutate(gmap = list(
    #   tm_shape(rx_polygons) +
    #   tm_polygons(col = "points_per_area") +
    #   tm_shape(input_centroid) +
    #   tm_symbols(size = 0.1)
    # )) %>%
    dplyr::select(form, input_type, rx_no_points) %>%
    mutate(rx_no_points = list(
      if (nrow(rx_no_points) == 0) {
        NULL
      } else {
        rx_no_points
      }
    ))
} else {
  rx_no_aa_data <-
    data.table(
      form = "999",
      input_type = "999"
    )
}
```

## Flag unreliable polygons

### Check the overlap and find area-weighted input rates

```{r }

input_pct <-
  input_polygons %>%
  left_join(., rx_no_aa_data, by = c("form", "input_type")) %>%
  # === intersect yield and input polygons to check overlaps ===#
  mutate(yield_input_int = list(
    st_intersection(
      dplyr::select(yield_polygons, yield_id, yield_area),
      dplyr::select(input_polygons, input_rate, ol_input_rate)
    ) %>%
      # === percentage of overlap relative to the are of a yield polygon ===#
      mutate(sub_pct = as.numeric(st_area(.)) / yield_area) %>%
      data.table()
  )) %>%
  mutate(yield_input_int_rx = list(
    if (Rx_data != "none") { #* if rx_data
      if (!is.null(rx_no_points)) {
        st_intersection(
          dplyr::select(yield_polygons, yield_id, yield_area),
          st_transform(rx_no_points, st_crs(yield_polygons))
        ) %>%
          # === percentage of overlap relative to the are of a yield polygon ===#
          mutate(sub_pct = as.numeric(st_area(.)) / yield_area) %>%
          data.table() %>%
          .[, input_rate := 0] %>%
          .[, ol_input_rate := 0] %>%
          .[, .(yield_id, yield_area, input_rate, ol_input_rate, geometry, sub_pct)]
      } else {
        NULL
      }
    } else {
      NULL
    }
  )) %>%
  mutate(yield_input_int = list(
    rbind(yield_input_int, yield_input_int_rx)
  )) %>%
  mutate(input_pct_data = list(
    copy(yield_input_int) %>%
      #--- total sub_pct by yield polygon ---#
      .[, tot_sub_pct := sum(sub_pct), by = yield_id] %>%
      #--- calculate sub_pct-weighted MEAN of applied rate ---#
      #* NOT divided by tot_sub_pct
      .[, wm_input_rate := sum(sub_pct * input_rate), by = yield_id] %>%
      #* if total area coverage is less than 5 %, then set the rate to be 0
      .[tot_sub_pct < 0.05, wm_input_rate := 0] %>%
      #--- weighted deviation from the mean ---#
      .[, dev_input_rate := sum(abs(sub_pct * (input_rate - wm_input_rate) / tot_sub_pct)), by = yield_id] %>%
      #--- calculate sub_pct-weighted MEAN of outlier flag ---#
      .[, ol := sum(sub_pct * ol_input_rate) / tot_sub_pct, by = yield_id] %>%
      #--- order by yield_id ---#
      .[order(yield_id), ] %>%
      .[, .(
        yield_id,
        tot_sub_pct,
        wm_input_rate,
        dev_input_rate,
        ol
      )] %>%
      setnames("wm_input_rate", "input_rate") %>%
      unique(by = "yield_id")
  )) %>%
  dplyr::select(input_type, form, var_name_prefix, yield_input_int, input_pct_data) %>%
  mutate(
    # === visualize overlap ===#
    gg_overlap = list(
      ggplot(input_pct_data) +
        geom_histogram(aes(x = tot_sub_pct)) +
        ggtitle(
          paste(
            "Histogram of the percentage of yield polygons \n overlapping with",
            input_type,
            "polygons"
          )
        )
    ),
    # === visualize mix of rates ===#
    gg_dev = list(
      ggplot(input_pct_data) +
        geom_histogram(aes(x = dev_input_rate)) +
        ggtitle(
          paste(
            "Histogram of the deviation of ",
            input_type,
            "\n to its mean by yield_id"
          )
        )
    )
  )
```

```{r }
input_pct$gg_overlap

input_pct$gg_dev
```

### An example polygon with a problem

```{r }
temp_yield_id <- input_pct$input_pct_data[[1]][tot_sub_pct > 2, yield_id][1]

overlapping_input <- input_pct$yield_input_int[[1]][yield_id == temp_yield_id]

temp_yield_poly <- filter(yield_polygons, yield_id == temp_yield_id)

ggplot() +
  geom_sf(data = st_as_sf(overlapping_input), aes(fill = factor(input_rate)), alpha = 0.5) +
  geom_sf(data = temp_yield_poly, color = "red", fill = NA, size = 1)

```

### Flag unreliable observations

```{r }
max_dev_dt <- max_dev_table[crop == trial_info$crop, ]
# === convert max_dev_table if in ha instead of ac ===#

if (units == "metric") {
  max_dev_dt[, max_dev_allowed := max_dev_allowed * 2.47105]
}

# === yield data after removing unreliable inputs ===#
yield_input_data_pre <-
  input_pct %>%
  dplyr::select(input_type, var_name_prefix, form, input_pct_data) %>%
  left_join(max_dev_dt, by = "input_type") %>%
  mutate(input_pct_data_pre = list(
    data.table::copy(input_pct_data) %>%
      # === 0 means within the threshold ===#
      #* if tot_sub_pct < 0.05, that can be considered GPS error
      .[, over_lap_test := fifelse(
        (tot_sub_pct > (1 - params$overlap_acceptance_pct) &
          tot_sub_pct < (1 + params$overlap_acceptance_pct)) |
          tot_sub_pct < 0.05,
        0,
        1
      )] %>%
      # === 0 means okay ===#
      .[, deviation_test := fifelse(dev_input_rate < max_dev_allowed, 0, 1)] %>%
      .[, .(yield_id, input_rate, ol, over_lap_test, deviation_test)]
  )) %>%
  mutate(input_pct_data_out = list(
    copy(input_pct_data_pre) %>%
      setnames(
        "input_rate",
        paste0(tolower(input_type), "_rate", "_", form)
      ) %>%
      setnames(
        "ol",
        paste0("ol_", tolower(input_type), "_", form)
      ) %>%
      setnames(
        c("over_lap_test", "deviation_test"),
        c(
          paste0(tolower(input_type), "_overlap", form),
          paste0(tolower(input_type), "_deviation", form)
        )
      ) %>%
      rename_at(vars(-one_of("yield_id")), ~ paste0(ifelse(is.na(var_name_prefix), "", paste0(var_name_prefix, "_")), .))
  ))
```


## Merge with Commercial Rx

This code assumes that the prescription rate variable is named the same as the `form` in the `metadata.json` file.

```{r eval = F}
cm_rx_data <-
  trial_info$rx_data %>%
  rowwise() %>%
  mutate(cm_rx = list(
    st_read(here("Data/Growers", ffy, "Raw", file))
  )) %>%
  mutate(yield_cm_rx = list(
    st_intersection(yield_point, st_transform(cm_rx, st_crs(yield_point))) %>%
      data.table() %>%
      .[, c("yield_id", form), with = FALSE] %>%
      setnames(form, paste0(form, "_", model))
  )) %>%
  pull(yield_cm_rx) %>%
  reduce(left_join, by = "yield_id")
```

## Prepare datasets for analysis and check

### Data for analysis

```{r }
yield_input_data <-
  yield_input_data_pre %>%
  pull(input_pct_data_out) %>%
  reduce(full_join, by = "yield_id") %>%
  inner_join(yield_polygons, ., by = "yield_id")
```

### Detailed data for inspection

```{r }
dt_trd_int <- tibble(type = "trial-design", int_info = list(yield_trd))

dt_input_int <-
  input_pct %>%
  mutate(type = paste0(input_type, "-", form)) %>%
  dplyr::select(type, yield_input_int) %>%
  rename(int_info = yield_input_int)

detailed_int_data <-
  rbind(dt_trd_int, dt_input_int) %>%
  # === add base n-rate column ===#
  mutate(n_base = n_base)
```

## Visualization

```{r }
viz <-
  yield_input_data_pre %>%
  mutate(input_data_viz = list(
    inner_join(yield_polygons, input_pct_data_pre, by = "yield_id") %>%
      st_as_sf()
  )) %>%
  dplyr::select(input_type, form, input_data_viz) %>%
  mutate(viz_overlap = list(
    ggplot(data = input_data_viz) +
      geom_sf(aes(fill = (over_lap_test == 1))) +
      scale_fill_discrete(name = form)
  )) %>%
  mutate(viz_deviation = list(
    ggplot(data = input_data_viz) +
      geom_sf(aes(fill = (deviation_test == 1))) +
      scale_fill_discrete(name = form)
  ))
```

**Overlap (1 means passing the overlap test)**

```{r }
viz$viz_overlap

```

**Deviation (1 means passing the deviation test)**

```{r }
viz$viz_deviation

```

## Save

```{r }
saveRDS(yield_input_data, file = here("Data", "Growers", ffy, "Intermediate/yield_input_data.rds"))

# yield_input_data <- readRDS(file = here("Data", "Growers", ffy, "Intermediate/yield_input_data.rds"))

saveRDS(detailed_int_data, file = here("Data", "Growers", ffy, "DataProcessingReport/detailed_intersection_info.rds"))
```


